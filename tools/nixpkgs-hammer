#!/usr/bin/env python3

import argparse
import io
import json
import os
import subprocess
import sys
import textwrap
from collections import defaultdict
from dataclasses import asdict, dataclass, field, is_dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Set, Tuple


@dataclass(frozen=True)
class SourceLocation:
    file: Path
    line: int
    column: Optional[int] = field(default=None)

    def stringify(self) -> str:
        with open(self.file, "r") as opened_file:
            all_lines = opened_file.read().splitlines()
            line_contents = all_lines[self.line - 1]
            line_spaces = " " * len(str(self.line))
            column = self.column if self.column is not None else 1
            pointer = " " * (column - 1) + "^"

            location_lines = [
                f"Near {self.file}:{self.line}:{self.column}:",
                line_spaces + " |",
                str(self.line) + " | " + line_contents,
                line_spaces + " | " + pointer,
            ]

        return "\n".join(location_lines)


@dataclass
class Report:
    name: str
    msg: str
    locations: List[SourceLocation]
    link: bool = field(default=True)
    severity: str = field(default="warning")

    def stringify(self) -> str:
        color = red if self.severity == "error" else yellow

        message_lines = [
            color(f"{self.severity}: {self.name}"),
            self.msg,
        ] + [loc.stringify() for loc in self.locations]

        if self.link:
            message_lines.append(
                f"See: https://github.com/jtojnar/nixpkgs-hammering/blob/master/explanations/{self.name}.md",
            )

        return "\n".join(message_lines)


@dataclass(frozen=True)
class Attr:
    # name of attr, e.g. python38Packages.numpy
    name: str
    # location in which the attr is defined, if exist
    location: Optional[SourceLocation]
    # path to the .drv file, if exists
    drv: Optional[Path]
    # path the the output of the drv in the nix store, if exists
    output: Optional[Path]


class JSONEncoder(json.JSONEncoder):
    def default(self, o: Any) -> Any:
        if is_dataclass(o):
            return asdict(o)

        if isinstance(o, Path):
            return str(o)

        # fallback to superclass
        return super().default(o)


def get_check_programs() -> Set[str]:
    # Each rule that is implemented as an external check program rather
    # than an overlay is installed onto our PATH, and the names of the
    # rules put into this environment variable.
    ast_checks = os.environ.get("AST_CHECK_NAMES")

    if ast_checks:
        return set(ast_checks.split(":"))

    return set()


def run_external_checks(
    attrs: List[Attr], excluded_rules: List[str]
) -> Dict[str, List[Report]]:
    rules = get_check_programs() - set(excluded_rules)
    if len(rules) == 0:
        return {}

    encoded_attrs = json.dumps(attrs, cls=JSONEncoder)
    result: Dict[Attr, List[Report]] = defaultdict(list)

    for rule in rules:
        json_text = subprocess.check_output([rule], text=True, input=encoded_attrs)
        if len(json_text) > 0:
            for attr_name, reports in json.loads(json_text).items():
                result[attr_name].extend(load_reports(reports))

    return dict(result)


def concatenate_messages(
    *report_sources: Dict[str, List[Report]]
) -> Dict[Attr, List[Report]]:
    result = defaultdict(list)
    for m in report_sources:
        for attr_name, report in m.items():
            result[attr_name].extend(report)
    return dict(result)


def escape_nix_string(val: str) -> str:
    return '"' + val.replace("\\", "\\\\").replace('"', '\\"') + '"'


def nix_eval_json(expr: str, show_trace: bool = False) -> Dict[Attr, List[Report]]:
    args = ["nix-instantiate", "--strict", "--json", "--eval", "-"]

    if show_trace:
        args.append("--show-trace")

    json_text = subprocess.check_output(args, text=True, input=expr)

    def maybe_path(s: Optional[str]) -> Optional[Path]:
        if s:
            return Path(s)
        return None

    def maybe_location(s: Optional[Dict]) -> Optional[SourceLocation]:
        if s:
            if isinstance(s.get("line"), str):
                s["line"] = int(s["line"])
            return SourceLocation(**s)
        return None

    result: Dict[Attr, List[Report]] = {}
    for name, data in json.loads(json_text).items():
        attr = Attr(
            name=name,
            output=maybe_path(data.get("outputPath")),
            drv=maybe_path(data.get("drvPath")),
            location=maybe_location(data["location"]),
        )
        result[attr] = load_reports(data["report"])

    return result


def load_reports(report_datas: List[Dict[str, Any]]) -> List[Report]:
    reports = []
    for report_data in report_datas:
        locations = []
        for location_data in report_data.pop("locations", []):
            loc = SourceLocation(**location_data)
            locations.append(loc)
        report = Report(
            locations=locations,
            **report_data,
        )
        reports.append(report)
    return reports


def bold(msg: str) -> str:
    return f"[1m{msg}[0m"


def yellow(msg: str) -> str:
    return f"[1;33m{msg}[0m"


def red(msg: str) -> str:
    return f"[1;31m{msg}[0m"


def green(msg: str) -> str:
    return f"[1;32m{msg}[0m"


def indent(text: str, steps=1) -> str:
    return textwrap.indent(text, " " * 4 * steps)


def main(args):
    script_dir = Path(__file__).parent
    overlay_generators_path = (script_dir.parent / "overlays").absolute()
    lib_dir = (script_dir.parent / "lib").absolute()

    attrs_nix = []
    attr_messages = []
    name_positions = []

    for attr in args.attr_paths:
        attrs_nix.append(escape_nix_string(attr))

        attr_messages.append(
            textwrap.dedent(
                f"""
            "{attr}" =
              let
                result = builtins.tryEval pkgs.{attr} or null;
                maybeReport = builtins.tryEval (result.value.__nixpkgs-hammering-state.reports or []);
              in
                if !(result.success && maybeReport.success) then
                  {{
                    report = [ {{
                      name = "EvalError";
                      msg = "Cannot evaluate attribute â€˜{attr}â€™ in â€˜{args.nix_file}â€™.";
                      severity = "warning";
                      link = false;
                    }} ];
                    location = null;
                    outputPath = null;
                    drvPath = null;
                  }}
                else if result.value == null then
                  {{
                    report = [ {{
                      name = "AttrPathNotFound";
                      msg = "Packages in â€˜{args.nix_file}â€™ do not contain â€˜{attr}â€™ attribute.";
                      severity = "error";
                      link = false;
                    }} ];
                    location = null;
                    outputPath = null;
                    drvPath = null;
                  }}
                else
                  {{
                    report = if maybeReport.success then maybeReport.value else [];
                    location = let
                      posSplit = builtins.split ":" result.value.meta.position;
                    in {{
                      file = builtins.elemAt posSplit 0;
                      line = builtins.elemAt posSplit 2;
                    }};
                    outputPath = result.value.outPath;
                    drvPath = result.value.drvPath;
                  }};
            """
            )
        )

        name_position = textwrap.dedent(
            f"""
            let
                result = builtins.tryEval cleanPkgs.{attr} or null;
            in
                if result.success && result.value != null then
                    result.value.meta.position
                else
                    null
            """
        )
        name_positions.append("(" + name_position.strip() + ")")

    # Our overlays need to know the built attributes so that they can check only them.
    # We do it by using functions that return overlays so we need to instantiate them.
    overlay_expressions = []
    for overlay_generator in overlay_generators_path.glob("*"):
        if overlay_generator.stem in args.excluded_rules:
            continue

        overlay = overlay_generator.name
        overlay_expressions.append(
            textwrap.dedent(
                f"""
            (import {overlay_generators_path}/{overlay} {{
                inherit builtAttrs packageSet namePositions;
            }})
            """
            )
        )

    name_positions_nix = (
        "[\n" + indent("\n".join(name_positions)) + "\n]" if name_positions else "[ ]"
    )
    attr_messages_nix = (
        "{\n" + indent("".join(attr_messages)) + "\n}" if attr_messages else "{ }"
    )
    overlays_nix = (
        "[\n" + indent("".join(overlay_expressions)) + "\n]"
        if name_positions
        else "[ ]"
    )
    all_messages_nix = textwrap.dedent(
        f"""
        let
            builtAttrs = [ {" ".join(attrs_nix)} ];
            packageSet = {args.nix_file};
            cleanPkgs = import {args.nix_file} {{ }};
            namePositions = builtins.filter (p: p != null) {indent(name_positions_nix, 2 + 1).strip()};

            pkgs = import {args.nix_file} {{
                overlays = {indent(overlays_nix, 2 + 2).strip()};
            }};
        in {indent(attr_messages_nix, 2 + 0).strip()}
        """
    )

    if args.show_trace:
        print("Nix expression:", all_messages_nix, file=sys.stderr)

    overlay_data = nix_eval_json(all_messages_nix, args.show_trace)
    overlay_reports = {attr.name: reports for attr, reports in overlay_data.items()}
    external_reports = run_external_checks(
        list(overlay_data.keys()), args.excluded_rules
    )
    all_messages = concatenate_messages(overlay_reports, external_reports)

    if args.json:
        print(json.dumps(all_messages, cls=JSONEncoder))
    else:
        for attr_name, messages in all_messages.items():
            # print(messages)
            print(bold(f"When evaluating attribute â€˜{attr_name}â€™:"), file=sys.stderr)
            if len(messages) > 0:
                print(
                    "\n".join([message.stringify() for message in messages]),
                    file=sys.stderr,
                )
            else:
                print(green("No issues found."), file=sys.stderr)
            print(file=sys.stderr)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="nixpkgs-hammer",
        description="check package expressions for common mistakes",
    )
    parser.add_argument(
        "-f",
        "--file",
        dest="nix_file",
        metavar="FILE",
        # Absolutize so we can refer to it from Nix.
        type=lambda p: Path(p).resolve(strict=True),
        # Nix defaults to current directory when file not specified.
        default=Path.cwd(),
        help=(
            "evaluate attributes in given path rather than the default "
            "(current working directory). The path needs to be importable "
            "by Nix and the imported value has to accept attribute set "
            "with overlays attribute as an argument."
        ),
    )
    parser.add_argument(
        "--show-trace",
        dest="show_trace",
        action="store_true",
        help="show trace when error occurs",
    )
    parser.add_argument(
        "--json",
        dest="json",
        action="store_true",
        help="Output results as JSON",
    )
    parser.add_argument(
        "-e",
        "--exclude",
        metavar="rule",
        dest="excluded_rules",
        action="append",
        default=[],
        help="rule to exclude (can be passed repeatedly)",
    )
    parser.add_argument(
        "attr_paths",
        metavar="attr-path",
        nargs="+",
        help="Attribute path of package to update",
    )

    args = parser.parse_args()

    main(args)
