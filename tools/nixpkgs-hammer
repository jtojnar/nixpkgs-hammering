#!/usr/bin/env python3

import os
from pathlib import Path
import argparse
import json
import subprocess
import sys
import textwrap
from typing import Dict, List
from collections import defaultdict


def get_ast_check_programs():
    # Each rule that is implemented as an AST check rather than an overlay
    # is installed onto our PATH, and the names of the rules put into this
    # environment variable.
    return set(os.environ['AST_CHECK_NAMES'].split(':'))


def attr_to_file_path(attr: str, nix_file: str) -> str:
    env = dict(os.environ)
    env['EDITOR'] = 'echo'

    proc = subprocess.run(
        ['nix', 'edit', '--experimental-features', 'nix-command', '-f', nix_file, attr],
        env=env,
        stdout=subprocess.PIPE,
        text=True,
        check=True,
    )
    return proc.stdout.strip()


def ast_checks(nix_file: str, attrs: List[str], excluded_rules: List[str]) -> Dict[str, List]:
    file_to_attr = defaultdict(list)
    for attr in attrs:
        file = attr_to_file_path(attr, nix_file)
        file_to_attr[file].append(attr)

    rules = get_ast_check_programs() - set(excluded_rules)

    result = defaultdict(list)
    for rule in rules:
        cmd = [rule] + list(file_to_attr.keys())
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, check=True, text=True)
        output = json.loads(proc.stdout)
        for file, report in output.items():
            for attr in file_to_attr[file]:
                result[attr].extend(report)
    return dict(result)


def concatenate_messages(*message_sources):
    result = defaultdict(list)
    for m in message_sources:
        for attr, report in m.items():
            result[attr].extend(report)
    return result


def escape_nix_string(val: str) -> str:
    return '"' + val.replace('\\', '\\\\').replace('"', '\\"') + '"'


def nix_eval_json(expr: str, show_trace: bool=False):
    args = ['nix-instantiate', '--strict', '--json', '--eval', '-E', expr]

    if show_trace:
        args.append('--show-trace')

    result = subprocess.check_output(
        args,
        encoding='utf-8',
    )
    return json.loads(result)


def bold(msg):
    return f'[1m{msg}[0m'


def yellow(msg):
    return f'[1;33m{msg}[0m'


def red(msg):
    return f'[1;31m{msg}[0m'


def green(msg):
    return f'[1;32m{msg}[0m'


def indent(text: str, steps=1) -> str:
    return textwrap.indent(text, ' ' * 4 * steps)


def stringify_location(file, line, column):
    with open(file, 'r') as opened_file:
        all_lines = opened_file.read().splitlines()
        line_contents = all_lines[line - 1]
        line_spaces = ' ' * len(str(line))
        pointer = ' ' * (column - 1) + '^'

        location_lines = [
            'Near ' + file + ':' + str(line) + ':' + str(column) + ':',
            line_spaces + ' |',
            str(line) + ' | ' + line_contents,
            line_spaces + ' | ' + pointer,
        ]

    return '\n'.join(location_lines)


def stringify_message(name, msg, locations=[], cond=True, link=True, severity='warning'):
    color = red if severity == 'error' else yellow

    message_lines = [
        color(f'{severity}: {name}'),
        msg,
    ] + list(map(lambda loc: stringify_location(**loc), locations))

    if link:
        message_lines.append(
            f'See: https://github.com/jtojnar/nixpkgs-hammering/blob/master/explanations/{name}.md',
        )

    return '\n'.join(message_lines)


def main(args):
    script_dir = Path(__file__).parent
    overlay_generators_path = (script_dir.parent / 'overlays').absolute()
    lib_dir = (script_dir.parent / 'lib').absolute()

    attrs_nix = []
    attr_messages = []
    name_positions = []

    for attr in args.attr_paths:
        attrs_nix.append(escape_nix_string(attr))

        attr_messages.append(textwrap.dedent(
            f'''
            "{attr}" = if pkgs.{attr} or null == null then
                [ {{
                    name = "AttrPathNotFound";
                    msg = "Packages in â€˜{args.nix_file}â€™ do not contain â€˜{attr}â€™ attribute.";
                    severity = "error";
                    link = false;
                }} ]
            else
                pkgs.{attr}.__nixpkgs-hammering-state.reports or [];
            '''
        ))

        name_position = textwrap.dedent(
            f'''
            let
                drv = cleanPkgs.{attr} or {{ }};
            in
                getDrvSourceLocation drv
            '''
        )
        name_positions.append('(' + name_position.strip() + ')')

    # Our overlays need to know the built attributes so that they can check only them.
    # We do it by using functions that return overlays so we need to instantiate them.
    overlay_expressions = []
    for overlay_generator in overlay_generators_path.glob('*'):
        if overlay_generator.stem in args.excluded_rules:
            continue

        overlay = overlay_generator.name
        overlay_expressions.append(textwrap.dedent(
            f'''
            (import {overlay_generators_path}/{overlay} {{
                inherit builtAttrs packageSet namePositions;
            }})
            '''
        ))

    name_positions_nix = '[\n' + indent('\n'.join(name_positions)) + '\n]' if name_positions else '[ ]'
    attr_messages_nix = '{\n' + indent(''.join(attr_messages)) + '\n}' if attr_messages else '{ }'
    overlays_nix = '[\n' + indent(''.join(overlay_expressions)) + '\n]' if name_positions else '[ ]'
    all_messages_nix = textwrap.dedent(
        f'''
        let
            inherit (import {lib_dir / 'standalone.nix'}) getDrvSourceLocation;
            builtAttrs = [ {" ".join(attrs_nix)} ];
            packageSet = {args.nix_file};
            cleanPkgs = import {args.nix_file} {{ }};
            namePositions = builtins.filter (p: p != null) {indent(name_positions_nix, 2 + 1).strip()};

            pkgs = import {args.nix_file} {{
                overlays = {indent(overlays_nix, 2 + 2).strip()};
            }};
        in {indent(attr_messages_nix, 2 + 0).strip()}
        '''
    )

    if args.show_trace:
        print('Nix expression:', all_messages_nix, file=sys.stderr)

    all_overlay_messages = nix_eval_json(all_messages_nix, args.show_trace)
    all_ast_check_messages = ast_checks(args.nix_file, args.attr_paths, args.excluded_rules)
    all_messages = concatenate_messages(all_overlay_messages, all_ast_check_messages)

    if args.json:
        print(json.dumps(all_messages))
    else:
        for attr, messages in all_messages.items():
            print(bold(f'When evaluating attribute â€˜{attr}â€™:'), file=sys.stderr)
            if len(messages) > 0:
                print('\n'.join(map(lambda msg: stringify_message(**msg), messages)), file=sys.stderr)
            else:
                print(green('No issues found.'), file=sys.stderr)
            print(file=sys.stderr)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog='nixpkgs-hammer',
        description='check package expressions for common mistakes',
    )
    parser.add_argument(
        '-f',
        '--file',
        dest='nix_file',
        metavar='FILE',
        # Absolutize so we can refer to it from Nix.
        type=lambda p: Path(p).resolve(strict=True),
        # Nix defaults to current directory when file not specified.
        default=Path.cwd(),
        help='evaluate attributes in given path rather than the default (current working directory). The path needs to be importable by Nix and the imported value has to accept attribute set with overlays attribute as an argument.',
    )
    parser.add_argument(
        '--show-trace',
        dest='show_trace',
        action='store_true',
        help='show trace when error occurs',
    )
    parser.add_argument(
        '--json',
        dest='json',
        action='store_true',
        help='Output results as JSON',
    )
    parser.add_argument(
        '-e',
        '--exclude',
        metavar='rule',
        dest='excluded_rules',
        action='append',
        default=[],
        help='rule to exclude (can be passed repeatedly)',
    )
    parser.add_argument(
        'attr_paths',
        metavar='attr-path',
        nargs='+',
        help='Attribute path of package to update',
    )

    args = parser.parse_args()

    main(args)
